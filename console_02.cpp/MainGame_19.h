#pragma once
#include<iostream>


using namespace std;

#pragma region 가상 함수 (객체지향의 수문장)
/*

▶ 가상 함수란?

- 부모 클래스의 특정 함수가 자식 클래스에 재정의 되었을 경우 부모 클래스의 참조
또는 포인터를 가지고 자식 클래스의 특정 함수를 실행시키는 메커니즘을 뜻한다.

- 가상 함수를 이용하면 객체의 계층 구조에 따라 자식 클래스의 특정 함수를 호출하는 것이 가능하다. (상속을 전제함)

▷ 가상 함수 특징

- C++ 클래스의 특성중 하나인 "다형성"을 지원하기 위해 "virtual" 이라는 키워드를 사용한다.

- 부모 클래스 내에서 virtual로 선언된 함수는 자식 클래스에서 오버라이딩 될 수 있다.

- 오버라이딩 되지 않는다면, 호출시 부모 클래스의 함수가 호출되고 오버라이딩 되었다면
함수 호출시 자식 클래스의 함수가 호출된다.


※ 다형성? 

- 여러가지를 표현할 수 있다는 뜻

- 자식 객체의 인스턴스를 부모 객체의 타입으로 간접 지정이 가능

-※ 인스턴스?

- 어느 클래스에 속하는 각 객체를 인스턴스라 한다.
ㄴ EX: 집(Home)이라는 클래스를 만들고 내방(myROOM)이라는 객체를 생성하면 (메모리 할당)
그 클래스의 인스턴스가 생성된다.


▶ 함수 오버로딩

- 서로 다른 함수들이 같은 이름을 공유하는 것

- 각 함수들은 매개변수의 타입, 갯수, 순서에 따라 호출될 함수가 정해지며 매개변수가 오버로딩의 핵심이 된다.
★
ㄴ 반환타입(리턴)은 함수 오버로딩의 조건을 충족하지 않는다

- void(요거) add " " {} 함수 오버로

※ 함수 오버로딩 요약
- 기존에 만들어 놓은 함수와 이름은 같지만 인자(수)의 형태가 다른 함수
- 인자(수)의 형태는 같은데 반환값만 다른 경우는 모호한 표현 -> 에러
- 같은 클래스 멤버 함수간. 발생한다.


▶ 함수 오버라이딩

- 상속된 클래스에서 상위 클래스에 구현된 함수를 재정의 하여 숨기는 것

- 함수의 원형은 상위 클래스에 구현된 함수와 일치해야 한다.

- 실제 호출되는 함수는 객체를 받는 매개변수의 타입에 따라 호출될 클래스의 함수가 결정된다. -> 정적 바인딩

- 오버라이딩은 리턴을 안보는 오버로딩과 달리 모든것을 보고 판단한다



A > B > C
이렇게 들어 갈 경우 A는 V B는 오버라이드 C 는 V 오버라이드






*/
#pragma endregion

// 부모
class  weapon
{
public:
	
	virtual void attack() { cout << " 무기로 공격" << endl; }
	

};

// 자식
class  gun : public weapon
{
public:
	
	void attack() { cout << "총으로 공격" << endl; }

};



class  bow : public weapon
{
public:

	void attack() { cout << "활로 공격" << endl; }

};


// 인터페이스(순수가상함수) 
/*
class  AClass
{
public:

	void AClassFunction() { cout << "A 클래스 부모 함수" << endl;}



	// 순수 가상함수 : 함수의 몸체가 정의 되지 않는 함수
	//virtual void AClassFunction() = 0; // NULL 과는 다르므로 NULL 넣으면 X 자체가 문법임 // 여게 모여있는 클래스를 인터페이스 클래스라고 한다. // 반드시 상속 참조를 통해 구현해야함.




	// 인터페이스는 반드시 소멸자를 가지고 있어야 한다.
	// 언어가 개정되며 소멸자를 생략하는 경우도 있지만 기본은 무조건 가지고 있어야 하는게 맞다.

	// - 0은 대입이 아닌 명시적으로 몸체를 정의하지 않겟다는 의미
	// - 순수 가상함수로만 이뤄진 클래스를 인터페이라고 한다.
	// ㄴ 인스턴스 x


	 AClass();
	virtual ~ AClass(); // 가상소멸자라고 불리움, VIRUAL 소멸자를 이용하면 아예 상속관계를 날려버림


};

 AClass:: AClass()
{
}

 AClass::~ AClass()
{
}
 */




class MainGame_19
{

private:

	weapon* _gun;
	weapon* _bow;
	weapon* _myweapon;



public:

	MainGame_19();
	~MainGame_19();



};

