/*
*/
#include<iostream>

using namespace std;

#pragma region 연산자+ 반복문
	/* 
	▶ 연산자란?

	- 프로그램이 동작할때 정해져 있는 특정역할을 수행하는 키워드를 의미한다.

	- 연산자를 이용하면 다양한 프로그램 로직을 만들어내는것이 가능하다.

	▷ 기본적인 연산자의 종류

	- 산술 연산자(+._,*,/,%)
	- 비교 연산자(==,!=,<,>,<,=<,>=)
	- 할당 연산자(=,=+,-+,*=,/+,%=)
	- 비트 연산자(&,|,^) (oxooo1 형태 한칸씩 밀음) (oxoo1o)요런식 플레이어 상태표시가능 (메모리효율 좋음)
	- 논리 연산자(&&,||, !)
	- 형변환 연산자((특정 자료형))



	▷ 형변환 연산자
	   ㄴ((특정 자료형)) 변수명
	      ㄴ int val =0:
		  ㄴ (float)val

	- c/c++ 언어는 형변환 연산자를 이용하면 간단하게 해당 변수의 자료형을 변경하는것이 가능하다.

	※ 강제형 변환에 대해

	- c 스타일 명시적 형변환은 가독성이 떨어지고 버그가 생길 여지를 만든다.
	- 강제로 형을 변환하기 때문에 
	- 그렇기 때문에 안전성을 우선시 한다면 다른 방법을 고려해 봐야 한다.

	※ 캐스팅 연산자를 사용하면 해결할 수 있다.

	C++ 타입 캐스팅 연산자
	- static_cast
	- dynamic_cast
	-const_cast
    -reinterpret_cast

	EX: 
	static_cast<type>(obj)
	ㄴ obj을 type으로 바꾼다.
    ㄴ 논리적으로 가능한경우 바꿔줌

    ▷ 산술연산자
	
	+: 더하기
	-: 빼기
	*: 곱하기
	/: 나누기 (몫만 남기고 나머지는 버린다.)
	%: 나머지 (나머지는 남기고 몫을 버린다.)
	
	▷ 비교 연산자(==,!=,<,>,<,=<,>=)
	
	num == num2;  → num과 num2가 같다.
	num != num2;  → num과 num2가 다르다(같지 않다.
	num < num2;   → num이 num2보다 작다.
	num > num2;   → num이 num2보다 크다.
	num <= num2; → num이 num2보다 작거나 크다
	num >= num2;  → num이 num2보다 크거나 같다.
	
	▷할당 연산자(=,=+,-+,*=,/+,%=)
	= 대입연산자: 오른쪽에 있는 값을 왼쪽에다 대입(넣는다.
	=+ 덧셈대입
	-+ 뺄셈대입
	*= 곱셈대입
	/+ 나눗셈대입
	%= 나머지대입
	
	
	▷비트 연산자(&,|,^) (oxooo1 형태 한칸씩 밀음) (oxoo1o)요런식 플레이어 상태표시가능 (메모리효율 좋음)
	
	

	비트 AND	(&)
	비트 OR	(|)
	비트 XOR(^)

	▷논리 연산자(&&,||, !)
	
	bool num;
	num    num이 만족하면(참) 실행한다.
	num && num2  num과 num2의 조건이 "둘다 참이면" 실행한다
	num || num2  num과 num2의 조건이 "둘중 하나라도 참이면" 실행한다
	!num   num이 만족하지 않으면(거짓) 실행한다.
	

	*/
#pragma endregion






void main()
{
	int numberA = 0;
	numberA = 2;
	numberA++;
	numberA = 6;
	numberA++;
	numberA = +5;
	numberA--;
	numberA -= 2;
	numberA *= 3;
	numberA /= 2;


	//?
	cout << "numberA의 값:" << numberA << endl;


	/*
	c/c++ 언어는 연산자를 애용해서 결과를 만들어 낼때 해당 연산자에 사용된 변수(데이터)의 자료형에 따라서 결과가 달라진다.

	ex
	정수 + 정수 = 정수
	정수 + 실수 = 실수

	- 기본적으로 연산자를 사용할떄는 동일한 자료형의 변수(데이터)를 지고 연산을 하는것이 원칙이지만 만약에 서로 자료형이 다를경우 연산자에 의해 데이터의 결과는
	값을 소실할수 있는 위험이 적은 자료형으로 만들어 진다.

	단, %(나머지 연산자)는 정수형 데이터 에만 사용하는 것이 가능하다

	*/




	/*

	▶ 반복문

	▷ 반복문이란?
	- 프로그램의 특정 부분을 일정 횟수 이상 반복해서 실행하도록 하기 위한 문법이며
	반복문을 이용하면 반복적으로 발생되는 구간을 간단하게 or 효율적으로 처리하는것이 가능하다.


	※ 문법을 잘 활용할 줄 안다면 편리한과 효율성이 폭발!

	▷ c/c++ 언어 반복문의 종류

	1. for 문
	- 구성
	ㄴ 초기식: 반목을 위한 변수의 선언 및 초기화
	ㄴ 조건식: 반목의 조건을 검사하는 목적으로 선언
	ㄴ 증감식: 반목의 조건을 거짓으로 만드는 증가 및 감소 연산


	for(초기식;조건식;증감식)
	{
	반복이 되는 문장
	}
	 ※ 특징: 초기값은 제일 처음에 한번만 수행이 되고 조건식이 참인 동안만 명령문을 반복수행한다.

	 (반복의 조건(횟수)를 정의할수 있으면 무조건 for문)
	 */

	int i;
	for (i = 0; i < 10; i++)
	{
		cout << "[" << i << "번째" << "]" << "공부하고 인내하면 너도 개발자" << endl;
	}


	// 변수를 선언하고 for문에서 초기화 하는건 대부분 c스타일
	// ㄴ 컴파일러 버전

	int numberB = 0;
	for (; numberB < 5; numberB++)
	{
		cout << "이렇게 사용을 한다면..?" << numberB << endl;

	}
	//- 포문은 필요에 따라 초기식, 조건식, 증감식 생략이 가능하다.
	//▷ 생략에 따른 for문의 유형
	//1. 초기화 생략             for(;i<10;i++)
	//2. 조건식 생략             for(i=1;i++)
	//3. 초기화 증감식 생략		  for(i<10)
	//4. 모두 생략				  for()	
	//1. 초기화 생략

		//i++ 후위증가
		//++i 전위증가
	int j = 1;
	for (int i = 0; i < 5; i++)
	{
		cout << "전위 증가" << ++j << endl;
		cout << "후위 증가" << j++ << endl;
	}
	cout << "\n";


	//반복문은 내부에 어떤 로직이 있다고 하더라도 기본적으로 반복해서 실행하는 것이 가능하기 때문에 반복문 안에 반복문을 다시 넣는것이 가능하다
	// ㄴ 중첩 반복문


	int f = 0;
	int k = 0;


	for (int f = 1; f < 10; f++)
	{


		int k = 0;
		for (int k = 1; k < 10; k++)
		{



		}
		cout << "2" << " x " << f << "   =   " << 2 * k << endl;
	}
	// 구구단 만들기	

		/* 반드시 이해 전위 후위


		2. while문

		-무한(loop): 반복 조건에 1(참)이 들어갈 경우 무한루프에 빠지게 된다.
		 ㄴ 후에 배울 break문으로 빠져나올 수 있다.
		 ㄴ 특징은 조건이 참(ture)일때만 작동을 한다.

		 -while문은 특정 조건을 주고 그 조건을 만족하는 동안 특정 영역을 계속해서
		 반복하는 구조를 가지고 있다.


		 ※ while문은 반복의 조건을 거짓(무너뜨리는)으로 만드는게 매우 중요하다

		*/

	int playerHp = 1000;

	while (playerHp > 0)
	{
		int hit = 100;
		playerHp -= hit;
		cout << "체력 =" << playerHp << endl;

		cout << '\n';
	}

		int numC = 0;
		while (numC < 5)
		{
			cout << "while문을 통한 반복" << endl;
			numC++;
		}
		
	

		//while문을 이용해 구구단 + 역순
		
		int numD = 1;
		int numE = 2;
		

		// int num 1개로하는 경우 2 ~9

		while (numD < 10)
		{
			
						
		cout << "2" << " X " << numD << "\t= " << numD * 2 << "\t\t\t"
		<< "3" << "X" << numD <<	"\t= " << numD * 3 << "\t\t\t"
		<< "4" << "X" << numD << "\t= " << numD * 4 << endl;
		numD++;
												
			
		}
		int numF = 1;
		int numG = 2;
		

//       2  5   8
// 
// 
	//   
			

		int numH = 1;

	
			while (numG < 10)
			{
				cout << "\n";

				while (numF < 10)
				{

					cout << numG << "X" << numF << "=" << numG * numF << "\n";

					numF++;
				}


				numG += 3;
				numF = 1;
				
				
			}
	// 가로로 3번 돌리고 내려오는것

			// 2 3 4
			// 5 6 7
			// 8 9

			printf("지옥에 온걸 환영한다!");

		/*============================================================================================
		
		3. do ~while문


		- while문 과의 차이점: 조건을 검사하는 시점이 다르다.

		- 일단 무조건 한번 실행이 된 이후 while 문의 조건을 검사하여 do ~ while문안의 문장을 실행 할것인지에 대해 판단한다.


		do
		{

		반복이 될 문장

		}while(조건식);



		*/
			//int numD = 0;
			do
			{
				cout << "첫번째 do ~ while문" << endl;
				numD++;

			} while (numD < -1);
				cout << "\n";

			do
			{
				cout << "두번째 do ~ while문" << endl;
				numD++;

			} while (numD < 3);
				cout << "\n";


				int total = 0, num = 0;

				do
				{
					cout << "숫자를입력하시오, (단 0을 입력하면종료)" << endl;
					cin >> num;
					total += num;

				} while (num != 0);


					cout << "입력한 숫자의 합계:" << total << "입니다" <<endl;
				cout << "\n";
				/*
				▶ while문과 do ~while문
				- 반복의 횟수가 정해져 있다면 while문 < - > do while문 이 자연스럽게 바뀌지만
				반복의 횟수가 정해져 있지 않고 언제 종료가 될지 모른다면 고민이 필요하다.
				ㄴ 위의 예시를 봤을 때 do ~ while문을 while문으로 바꾸면 바로 종료가 된다.
				ㄴ num = 0

				- 강제로 while문에 진입을 시키기 위해서는 num을 0이 아닌 값으로 초기화를 진행해야 하는데
				이러면 내가 소스 자체를 컨트롤 하는게 아니라 소스에 맞춰서 코딩 방식을 바꾸는 느낌이 난다.
				ㄴ 좋은 방식이 아니다.

				*/


				cout << "do while 구구단" << "\n";

				int num1 = 2;
				

				do 
				{
					int num2 = 1;
					cout << num1 << "단 출력" << endl;

					cout << "\n";
					do
					{
						
						cout << num1 << "X" << num2 << "=" << num1 * num2 << "\n";

						num2++;

					} while (num2 < 10);

					num1++;
					
					cout << endl;
					num2 = 1;
				} while (num1 < 10);

				



}